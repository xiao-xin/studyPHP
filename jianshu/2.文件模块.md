## 前言
这个章节主要是通过Laravel来搭建文章相关的功能，也是非常重要的章节。

## 功能和技术点分析
1. 运用路由来访问控制器
2. 使用数据库迁移来设计表
3. 使用模型来访问数据库
4. 文章列表、新增、编辑、删除的功能开发


## Laravel的路由
路由定义在`route/web.php`文件下，主要是web相关的路由，如果是`api`相关的路由设置在`api.php`文件下。

分析`web.php`文件中默认的路由
```php
// 第一个参数是访问url
// 第二个参数是一个回调函数
Route::get('/',function(){
	view('welcome');
});
```

除了可以把路由定位到回调函数，还可以定位到http模块下的控制器Controller中，
```php
#第二个参数格式为"命令空间\控制器名@方法名"
Route::get('/','\App\Http\Controllers\IndexController@index')
```

### 路由方法
Laravel中的路由完美的支持HTTP协议中的方法，比如get、put、post、delete、patch等.
```php
#post
Route::post('/user','\App\...');
#支持所有方法
Route::any('/post','\App..');
#支持匹配的方法
Route::match(['post','get'],'/get','\App..');
```

我们知道表单提交的HTTP方法只支持get、post方法，如果要使用其他的方法，只能用隐藏与的方式来访问。
```html
<form method="POST" action="/">
<input type="hidden" name="_method" value="PUT"/>
</form
```
这样的表单提交到后台，就可以使用我们定义的路由中的`put`方法进行处理。

### 路由参数
可以在的定义路由时设置路由参数。
```php
#{id}就是占位符,之后会用请求连接中匹配到的字符填充
Route::put('/user/{id}',fuction($id){
	return  $id;
});
```

### 路由分组
我们把一堆具有相同特征的路由放在一起组成一个路由分组，比如url前面一部分相同的路由可以组合在一起。
```php
#分组的第一个参数传递一个数组，至于内容是什么，根据情况确定
#第二个参数是一个回调函数，函数里面可以定义这个分组下的路由
#在里面定义的路由就不用加前缀了，以"/"开始即可。
Route::group(['prefix'=>'user'],function(){
    Route::get('/',function(){
        return "this is user group";
    });
    Route::get('/{id}',function($id){
        return $id;
    });
});
```

### 绑定模型
路由参数中我们可以直接绑定模型，比如用户登录，可以直接通过用户id的获取用户信息，只要在控制器方法中的参数类型定义为模型类就可以了
```php
 Route::get('/user/{user}','\App\Http\Controllers\UserController@show');

 // user控制器
 // 这样$user就是User类的实例，会自动的以主键ID值查找数据。
 public function  show(\App\User $user)
 {
 	return $user->username;
 }
```

## 创建控制器
使用命令可以创建控制器
```bash
php artisan make:controller PostController 
```

编辑控制器中的方法
```php
/**
 * 文章控制器
 * @package App\Http\Controllers
 */
class PostController extends Controller
{
    public function index()
    {
        return 'fasd';
//        return view();
    }

    public function create()
    {

    }

    public function store()
    {

    }

    public function show()
    {

    }

    public function edit()
    {

    }

    public function update()
    {

    }

    public function destroy()
    {

    }
}
```

## 创建路由
通过路由定位到控制器。
```php
//use Illuminate\Support\Facades\Route;

Route::get('/posts', '\App\Http\Controllers\PostController@index');
// 创建文章
Route::get('/post/create', '\App\Http\Controllers\PostController@create');
Route::post('/post', '\App\Http\Controllers\PostController@store');
// 编辑文章
Route::get('/post/{post}/edit', '\App\Http\Controllers\PostController@edit');
Route::put('/post/{post}', '\App\Http\Controllers\PostController@update');
// 删除文件
Route::delete('/post/{post}', '\App\Http\Controllers\PostController@destroy');
// 文章详情
Route::get('/post/{post}', '\App\Http\Controllers\PostController@show');
```
上面写了一堆的路由注册，可以用一句话处理
```php
#定义一个资源路由
Route::resource('posts','\App\Http\Controllers\PostController')
```

## 模板渲染
在控制器中可以使用`view`函数来渲染模板
```php
public function index()
{
	// laravel中使用"."分隔符代替"/"
	return view('post.index')
}
```
在模板中需要引入js,css,img,这些资源我们放在public目录中，目录结构：
```
public
 ├─css
 ├─img
 ├─js
 cfont
```
后台的静态资源和前台的可以分开 ，比如:
```
public
 ├─assets
 │  ├─backend
 │  │   ├─css
 │  │   ├─img
 │  │   ├─js
 │  │   ├─....
 │  ├─frontend
 │  │   ├─css
 │  │   ├─img
 │  │   ├─js
 │  │   ├─...
```
结构可以根据自己的方式来，没有特定的方式。

页面一开始是静态的html，laravel中需要.balde.php后缀的文件，所以我们需要改变文件类型，文章相关的页面：
```
index.blade.php
show.blade.php
create.blade.php
edit.blade.php
``` 

### 模板规则
模板使用的是balde模板

模板常用的语法
```
{{$id}} 输出变量
@if($id > 0) @enif if判断
@foreach($posts as $post)  @endforeach

extends yield content section 模板继承
include 模板引入
```

我们可以定义一个模板框架，对不变的地方做成一个layout，然后变化的地方引入或者替换即可，这样我们的页面布局就确定下来了，不用重复的写一样的html。

### 使用模板继承
我们可以把页面公共的部分提取到公共页面，不同的部分使用替换的方式，这样就可以复用页面了

首先创建`layout/main.blade.php`页面，把公共的部分提取到这个页面，删除变化的地方，并使用`@yield('content')`来代替删除的部分

接下来比如文章列表页，删除和`main.blade.php`页面一样的地方，保留变化的部分。
并改造这个页面
```html
@extends('layout.main')
@section('content')
 html代码
@stop
```

这样在渲染文章列表页面时就会把继承中的内容，填充到列表页面。 一旦我们要修改相同的部分，只需要修改`layout/main`

能够继承的页面前提是有相同的部分，如果模板没有相同的地方，那就不需要继承了。

建立`layout/main`模板后，里面有一些内容可以单独提取出来，方便后面管理，比如菜单、底部、广告等等都可以提取到单独的页面。
```html
@include('layout.nav')
...
@yield('content')
...
@include('layout.sidebar')
...
@include('layout.footer')
```
这样的好处就是如果要改动底部，只需要改动footer即可。

## 数据库迁移
我们可以使用命令创建数据库迁移文件
```bash
php artisan make:migration create_posts_table
```
注意这里的数据库迁移文件名，我们可以"create"+表名（复数形式）+"table"，修改表的名字又会不一样。

执行命令后会生成一个迁移文件在`database/migrations`目录下，编辑这个文件。
```php
class CreatePostsTable extends Migration
{
    /**
     * Run the migrations.
     * 运行数据库迁移会执行这个方法
     * @return void
     */
    public function up()
    {
    	// Schema::create 用来创建表
    	// Blueprint类的方法不熟悉的话可以看别人是怎么写的
        Schema::create('posts', function (Blueprint $table) {
            $table->increments('id');
            $table->string('title',100)->default("");
            $table->text('content');
            $table->unsignedInteger('user_id')->default(0);
            // 这里表示会生成两个created_at,updated_at两个时间字段
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     * 回滚迁移会执行这个方法
     * @return void
     */
    public function down()
    {
    	// 执行迁移创建了，回滚迁移我们就删除这个表
        Schema::dropIfExists('posts');
    }
}
```

接下来我们执行命令`php artisan migrate`，会遍历`migrations`目录下的所有迁移文件，按照时间一个个的迁移到数据库中，已经迁移的文件不会再次迁移。执行命令后会显示哪些迁移文件被迁移到数据库了。
```bash
Migrating: 2014_10_12_000000_create_users_table
Migrated:  2014_10_12_000000_create_users_table
Migrating: 2014_10_12_100000_create_password_resets_table
Migrated:  2014_10_12_100000_create_password_resets_table
Migrating: 2020_11_13_133502_create_posts_table
Migrated:  2020_11_13_133502_create_posts_table
```

在执行数据库迁移文件时可能会员,string字符串超出mysql的varchar字符长度，所以这里我们要修改一下。
```php
class AppServiceProvider extends ServiceProvider
{
	public function boot()
	{
	    // utf8mb4 767/4
	    Schema::defaultStringLength(191);
	}
}
```
这样我们就设置了mysql的varchar的默认字符长度为191，至于什么是`AppServiceProvider`，后面用到了再说。

如果我们对刚刚的迁移后悔了，可以回滚迁移。
```bash
php artisan migrate:rollback
``` 

## 模型