## 创建和路由
首先是权限相关的逻辑，也就是注册、登录、修改用户信息。

先创建一个控制器，这个控制器在`App\Http\Controller\Wx`空间下，表示这里面的内容都是和微信相关的。

然后我们找到路由服务提供者，添加一个和微信相关的路由文件。
```php
// RouteServiceProvider.php
protected function mapWxRoutes()
{
    Route::prefix('wx')
        ->namespace($this->namespace.'\Wx')
        ->group(base_path('routes/wx.php'));
}

#上面的方法要在map方法中调用
public function map()
{
    // 定义微信路由
    $this->mapWxRoutes();
}
```

然后添加一个`wx.php`的路由配置文件,这个配置文件中的内容会读取到我们上面设置的wx路由组中.
```php
Route::post('auth/register','AuthController@register');

```	

## 知识点补充，
如果在使用中遇到如下问题，表示php的内存大小设置有点小了，要调大一点。首先是使用`phpinfo`函数获取php.ini文件在哪里，在文件中调整`memory_limit`配置就可以了。
```
Allowed memory size of 134217728 bytes exhausted
```

像这样修改,把它的值调大就可以了。
```
; Maximum amount of memory a script may consume (128MB)
; http://php.net/memory-limit
memory_limit = 2012M
```

还有我们修改了一些Nginx的配置，具体作用现在不清楚
```
# 这些配置放在nginx.conf文件中的http块中
client_max_body_size 1024m;
client_body_buffer_size 10m;
client_header_buffer_size 10m;
proxy_buffers 4 128k;
proxy_busy_buffers_size 128k;
```

初次之外我们要把我们的项目所有者改为php-fpm的用户组,配置用户组的在Php-fpm的配置文件中`/etc/php/7.3/fpm/pool.d/www.conf`.
```ini
;       will be used.
user = vagrant
group = vagrant
```

然后我们使用命令修改项目的所属组
```
chown -R vagrant:vagrant ~/Code/dianshang
```



```

// php.ini
; Maximum execution time of each script, in seconds
; http://php.net/max-execution-time
; Note: This directive is hardcoded to 0 for the CLI SAPI
max_execution_time = 300
```

### 配置环境遇到的问题。

1. 遇到的第一个问题就是laravel错误提示不显示，这个一开始我们以为是laravel的问题，最后查看laravel日志有生成，看nginx出现了问题，这个问题还比较棘手。
2. 有的时候会遇到502的问题，比较难以解决，基本上的问题都是fpm设置的问题，或者说nginx缓存设置的问题，下面有几个链接，除了问题可以看下。
https://blog.csdn.net/u010391029/article/details/46884107
https://blog.csdn.net/houzhiwen_yy/article/details/52597541
https://www.cnblogs.com/ahaii/p/5776809.html

3. 如果我们的代码有语法错误，laravel7没有提示出来，直接返回500，不知道什么原因，应该是配置的问题，最后我们发现是没有开启bug模式，导致页面提示500

4. 上面遇到的502的问题我们一致没有找到方法，下来在具体看下，主要是还是要学习nginx的一些知识，和fpm一些东西。

5. 不要开启php-fpm中的错误日志,一旦开启后，错误直接记录到fpm的日志中，将不会把错误日志交给nginx,而是直接返回502.
```
;php_flag[display_errors] = on
;php_admin_value[error_log] = /var/log/fpm-php.www.log
```
6. 选择homestead 的不同php版本，可以看这篇文章指导内容。https://learnku.com/articles/50820

7. 查看系统版本
```bash
# 查看unbuntu的版本
lsb_release -a
cat /etc/issue
# 查看系统内核版本
uname -a
```

8. homestead 手动升级php版本到php7.4
```bash
安装 PHP
sudo apt update
sudo apt-get -y install php7.4-mysql php7.4-fpm php7.4-mbstring php7.4-xml php7.4-curl
切换 PHP
sudo update-alternatives --config php
```

9. php执行超时的设置，看下这篇文章。。
https://www.cnblogs.com/guoshuai-yangxu/p/11820818.html


10. php安装xdebug扩展
在ubuntu系统中使用命令即可安装。
```bash
sudo apt-get -y install php7.4-xdebug

# 值xdebug.ini文件中配置xdebug的配置
# 这里也是拷贝的，可以看下是什么意思。
zend_extension="/etc/php/7.4/lib"
 
xdebug.remote_enable = On
xdebug.profiler_enable = On
xdebug.auto_trace=On
xdebug.profiler_enable_trigger = On
xdebug.profiler_output_name = cachegrind.out.%t.%p
xdebug.profiler_output_dir ="/etc/php/7.4/log/tmp"
xdebug.show_local_vars=0
xdebug.remote_port=9000
xdebug.remote_host="127.0.0.1"
```

11. 单元测试
一开始我们使用Phpstorm来搭建远程单元测试，但是始终有问题，主要是我们对phpunit测试不是很清楚。

最后我们直接调用vendor目录下的phpunit就可以执行测试单元了。
```bash
./vendor/bin/phpunit
```

具体的单元测试，要学习单元测试的知识点，不然也不会用。


## Laravel 发送短信
laravel中发送短信非常的优雅，使用下面这个包就可以发送很多地方的短信服务。
```
composer require overtrue/eays-sms
```

要融入Laravel，可以使用notification ，提供的另外一个整合了easy-sms包的laravel扩展包。
```bash
# 安装扩展包
composer require "overtrue/easy-sms"
# 生成easy-sms配置文件
php artisan vendor:publish --provider="Leonis\Notifications\EasySms\EasySmsChannelServiceProvider"
```

接下来创建`notification`类
```base_path
# 使用命令创建notification类，这个类在app/notifications目录下。
php  artisan  make:notification  VerificationCode
```

编辑这个类，删除不需要的toEmail等等返回
```php
class VerificationCode extends Notification
{
    use Queueable;

    /**
     * 验证码
     * @var integer
     */
    protected  $code;
    /**
     * Create a new notification instance.
     * @param  $code
     * @return void
     */
    public function __construct( $code)
    {
        $this->code =$code;
    }

    /**
     * Get the notification's delivery channels.
     *
     * @param  mixed  $notifiable
     * @return array
     */
    // 注册使用的通道
    public function via($notifiable)
    {
        return [EasySmsChannel::class];
    }

    // 使用easysms 扩展包来发送数据
    public function toEasySms($notifiable)
    {
        return (new EasySmsMessage())->setContent("你的验证码:6379")
            ->setTemplate('SMS_188991689')
            ->setData(['code'=>$this->code]);
    }
}
```

要使用这个通知很简单，只要给用户发送通知就可以了。
```php
  // toto 发送验证码
 // 第一个方法是路由，第一个参数传递via方法中注入的通道，第二个参数是easysms扩展实现的PhoneNumber类，类实例化需要手机号和手机区号作为参数
// 第二个方法是notify，这个参数实例化一个通知类，就是上面用命令生成的Notification
Notification::route(EasySmsChannel::class,new PhoneNumber(18113415945,86))
    ->notify(new VerificationCode($code));
```

具体的原理还是要去看源码才知道，所以这里就不展开讲了。

##  发送手机验证码
这里我们来讨论一下如何实现给手机发送验证码，以及使用redis来实现防刷的功能。

```php

public function cpatcha(Request $request)
{
	$mobile=  $request ->input('request');
	$validator = Validator::make(compact('mobile'),['mobile'=>$mobile]);
	if ($validator->fails()){
		return ['errno'=>704,'errmsg'=>'手机号不正确'];
	}

	$lock = Cache::add('register_captcha_lock_'.$mobile,1,60);
	if (!$lock){
		return ['errno'=>705,'errmsg'=>'验证码已经发送'];
	}

	$count_key = 'register_captcha_count_'.$mobile;
	if (Cache::has($count_key)){
		if (Cache::get($count_key)>10){
			return ['errno'=>705,'errmsg'=>'验证码已经超过每日发送次数']; 
		}
		Cache::increment($count_key);
	}else{
		Cache::add($count_key,1,Carbon::tomorrow()->differInSeconds(now()));
	}

	$code =random_int(100000,999999);
	Cache::put('register_captcha_'.$mobile,$code,600);
	Notification::route(EasySmsChannel::class,New PhoneNumber(18113415945,86))->notify(new VerificationCode());
}
```

上面我们学习到了这几点，首先是怎么使用redis来保存验证码。

1. 第一点在`.env`文件中设置缓存驱动`CACHE_DRIVER`等于`redis`.
2. 使用`Cache Facade`就会使用`redis`作为缓存了，默认redis的可以会以`laravel_database_laravel_cache`开头。
3. 我们并不是只使用了一个redis key来存储验证码相关的数据，首先是一个保存验证码的key, 这个key名为`register_captcha_$mobile`，缓存时间10分钟，使用的是put方法，这个方法如果key存在会被覆盖。
4. 第二个key是用来缓存验证码的规则的，1分钟只能发送一次验证码，所以我们使用add方法，add方法如果key存在则返回false,所以我们缓存它1分钟后过期`Cache::add('register_captcha_lock_$mobile',1,60)`.
5. 第三个key也是用来缓存规则的，一天只能发送10次，这里要稍微复杂一下，首先是我们用到了`increment`自增方法，必须要保证key是否存在，所以这里用到了has，没有则add,有就get一下现在已经发送了几个了，没有超过就增加1.
```php
$count_key = 'register_captcha_cout_'.$mobile;
if (Cache::has($count_key)){
	if (Cache::get($count_key)>10){
		return ['errno'...];
	}
	Cache::increment($count_key);
}else{
	// 记住这里第三个参数是到第二天此刻的剩余的秒数
	// 使用了一个第三方的Carbon扩展来计算
	Cache::add($count_key,1,Carbon::tomorrow()->differInSeconds(now()));
}
```

### 安装redis扩展
如果你使用的Php版本没有redis扩展，可以使用命令安装，如果是编译安装，需要使用编译安装的方式来安装，这里列举命令安装。
```bash
sudo apt-get install -y php7.4-redis
sudo service php7.4-fpm restart
# 测试是否安装redis
php -i | grep redis
```


